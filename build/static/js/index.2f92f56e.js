(()=>{"use strict";var e,t,i,n,o={976(e,t,i){var n=i(290);let o={class:"App"},r={class:"App-main-no-navbar"},a={class:"search-container-no-navbar"},s={class:"cards-list"},l=["onClick","title"],c=["innerHTML"],p={key:0,class:"no-results"};i(791);var d=i(935);let u=[{id:"electron-intro",title:"What is Electron?",content:"<p>Electron is a framework for building cross-platform desktop applications using web technologies like HTML, CSS, and JavaScript. It combines the Chromium rendering engine and the Node.js runtime.</p><p>With Electron, you can develop desktop applications that run on Windows, macOS, and Linux using familiar web technologies. Popular applications like Visual Studio Code, Slack, Discord, and WhatsApp Desktop are built with Electron.</p>",category:"framework",tags:["electron","desktop","chromium","nodejs","cross-platform"]},{id:"electron-architecture",title:"Electron Architecture",content:"<p>Electron applications have two main processes: the Main Process and the Renderer Process. The Main Process controls the life cycle of the app and creates browser windows. The Renderer Process renders the UI and runs in the browser window.</p><p>Communication between processes happens via IPC (Inter-Process Communication). This architecture allows for secure separation of concerns while maintaining flexibility.</p>",category:"architecture",tags:["main-process","renderer-process","ipc","architecture"]},{id:"electron-security",title:"Electron Security Best Practices",content:"<p>Security is crucial in Electron applications. Important practices include: enabling context isolation, disabling nodeIntegration when possible, using CSP (Content Security Policy), validating all input, and sanitizing user-provided content.</p><p>Always run Electron in a secure context and keep your dependencies updated. Follow the principle of least privilege for all operations.</p>",category:"security",tags:["security","context-isolation","csp","best-practices"]},{id:"electron-packaging",title:"Packaging and Distribution",content:"<p>Electron applications can be packaged for distribution using tools like electron-builder, electron-forge, or electron-packager. These tools create installable executables for Windows, macOS, and Linux.</p><p>Configuration includes app metadata, icons, installer options, and platform-specific settings. Proper packaging ensures a professional user experience across all platforms.</p>",category:"packaging",tags:["packaging","distribution","electron-builder","installer"]},{id:"electron-native-apis",title:"Native Operating System APIs",content:"<p>Electron provides access to native OS features through its APIs: file system operations, dialog boxes, notifications, tray icons, clipboard, and more. These APIs bridge the gap between web technologies and desktop functionality.</p><p>Common native integrations include file dialogs, system notifications, context menus, and deep OS integration for a native-like experience.</p>",category:"api",tags:["native-api","file-system","notifications","dialogs"]},{id:"electron-performance",title:"Performance Optimization",content:"<p>Optimizing Electron apps involves reducing memory usage, improving startup time, and efficient resource management. Techniques include code splitting, lazy loading, proper cleanup of event listeners, and optimizing asset loading.</p><p>Monitor performance with Chrome DevTools and consider using native modules for CPU-intensive tasks. Efficient IPC communication also improves responsiveness.</p>",category:"performance",tags:["performance","optimization","memory","startup-time"]},{id:"electron-development",title:"Development Workflow",content:"<p>Effective Electron development involves using tools like Hot Module Replacement (HMR), development servers, and proper debugging setups. Use electron-reload for automatic restarts during development.</p><p>Separate development and production configurations, implement proper error handling, and use build tools to automate repetitive tasks for a smooth development experience.</p>",category:"development",tags:["development","workflow","debugging","hmr"]},{id:"electron-versions",title:"Version Management",content:"<p>Managing Electron versions is important for stability and security. Regularly update to newer versions to get security patches and performance improvements. Consider the compatibility of Node.js and Chromium versions in each Electron release.</p><p>Test your application thoroughly after version upgrades and maintain a consistent version across your team to avoid compatibility issues.</p>",category:"maintenance",tags:["version","updates","compatibility","maintenance"]}],m={electron:["<p>Electron is a framework that enables you to create desktop applications using web technologies like HTML, CSS, and JavaScript. It combines Chromium and Node.js to build cross-platform desktop apps.</p>","<p>Electron applications have two main processes: the Main Process and the Renderer Process. The Main Process controls the life cycle of the app and creates browser windows. The Renderer Process renders the UI.</p>","<p>Security is crucial in Electron applications. Best practices include enabling context isolation, disabling nodeIntegration when possible, and using Content Security Policy (CSP) to prevent XSS attacks.</p>","<p>Electron provides access to native OS features through its APIs: file system operations, dialog boxes, notifications, tray icons, clipboard, and more. These APIs bridge the gap between web technologies and desktop functionality.</p>","<p>Electron applications can be packaged for distribution using tools like electron-builder, electron-forge, or electron-packager. These tools create installable executables for Windows, macOS, and Linux.</p>","<p>Performance optimization in Electron involves reducing memory usage, improving startup time, and efficient resource management. Techniques include code splitting, lazy loading, and proper cleanup of event listeners.</p>"],architecture:["<p>Electron applications follow a multi-process architecture with the Main Process managing application lifecycle and creating browser windows, while Renderer Processes handle UI rendering.</p>","<p>Communication between processes happens via IPC (Inter-Process Communication). This architecture allows for secure separation of concerns while maintaining flexibility.</p>","<p>Security architecture in Electron involves context isolation, proper handling of user input, and restricting access to Node.js APIs in the renderer process.</p>","<p>Application architecture patterns in Electron include using preload scripts to expose limited APIs to the renderer, and maintaining a clear separation between main and renderer responsibilities.</p>","<p>Modern Electron applications often use a modular architecture with separate modules for main process, renderer process, and shared utilities.</p>"],security:["<p>Security is crucial in Electron applications. Important practices include: enabling context isolation, disabling nodeIntegration when possible, using CSP (Content Security Policy), validating all input, and sanitizing user-provided content.</p>","<p>Context Isolation is a security feature that ensures that your preload scripts and Electron's internal logic run in a separate context to the website loaded in a WebContents.</p>","<p>Content Security Policy (CSP) helps prevent cross-site scripting (XSS) attacks by allowing you to restrict which resources can be loaded by the page.</p>","<p>Node.js integration in the renderer process should be disabled unless absolutely necessary. When needed, expose only the required APIs through preload scripts.</p>","<p>Always validate and sanitize user input, especially when interacting with the file system or executing external processes.</p>"],packaging:["<p>Electron applications can be packaged for distribution using tools like electron-builder, electron-forge, or electron-packager. These tools create installable executables for Windows, macOS, and Linux.</p>","<p>electron-builder is a complete solution for packaging and building a ready-for-distribution Electron app. It supports multiple formats for each platform and provides advanced configuration options.</p>","<p>Configuration for packaging includes app metadata, icons, installer options, and platform-specific settings. Proper packaging ensures a professional user experience across all platforms.</p>","<p>Code signing is important for distributing Electron applications, especially on macOS and Windows. It verifies the authenticity of the application and prevents tampering.</p>","<p>Auto-updater functionality can be implemented using libraries like electron-updater to provide seamless updates to users.</p>"],api:["<p>Electron provides access to native OS features through its APIs: file system operations, dialog boxes, notifications, tray icons, clipboard, and more. These APIs bridge the gap between web technologies and desktop functionality.</p>","<p>Common native integrations include file dialogs, system notifications, context menus, and deep OS integration for a native-like experience.</p>","<p>IPC (Inter-Process Communication) is used to communicate between the main and renderer processes. Use ipcMain in the main process and ipcRenderer in the renderer process.</p>","<p>Powerful APIs like app, BrowserWindow, Menu, Tray, and nativeImage provide access to operating system-level functionality.</p>","<p>Preload scripts can be used to expose specific APIs to the renderer process while maintaining security.</p>"],performance:["<p>Optimizing Electron apps involves reducing memory usage, improving startup time, and efficient resource management. Techniques include code splitting, lazy loading, proper cleanup of event listeners, and optimizing asset loading.</p>","<p>Memory management is crucial in Electron applications. Avoid memory leaks by properly cleaning up event listeners, timers, and references when windows are closed.</p>","<p>Startup performance can be improved by optimizing the main process initialization and deferring non-critical operations until after the application has loaded.</p>","<p>Renderer process performance benefits from standard web optimization techniques: efficient JavaScript, optimized images, and proper use of web workers for heavy computations.</p>","<p>Monitor performance with Chrome DevTools and consider using native modules for CPU-intensive tasks. Efficient IPC communication also improves responsiveness.</p>"],development:["<p>Effective Electron development involves using tools like Hot Module Replacement (HMR), development servers, and proper debugging setups. Use electron-reload for automatic restarts during development.</p>","<p>Debugging Electron applications can be done using Chrome DevTools for the renderer process and standard Node.js debugging tools for the main process.</p>","<p>Development workflow includes separate configurations for development and production, proper error handling, and using build tools to automate repetitive tasks.</p>","<p>Testing Electron applications involves unit tests for business logic, integration tests for IPC communication, and end-to-end tests for user interactions.</p>","<p>Common development patterns include using preload scripts, implementing proper error boundaries, and structuring code for maintainability.</p>"],maintenance:["<p>Managing Electron versions is important for stability and security. Regularly update to newer versions to get security patches and performance improvements.</p>","<p>Testing your application thoroughly after version upgrades and maintain a consistent version across your team to avoid compatibility issues.</p>","<p>Keeping dependencies updated helps maintain security and performance. Use tools like npm audit to identify vulnerable packages.</p>","<p>Documentation and code organization are important for long-term maintenance of Electron applications.</p>","<p>Monitoring application usage and crash reports helps identify issues in production environments.</p>"],default:["<p>Modern development practices emphasize automation, testing, and continuous integration. These methodologies help teams deliver high-quality software more efficiently.</p>","<p>Performance optimization is crucial for user experience. Techniques include code splitting, lazy loading, caching strategies, and efficient algorithms.</p>","<p>Security should be considered at every stage of development. Implement proper authentication, authorization, input validation, and secure coding practices.</p>","<p>Architectural patterns provide proven solutions to common problems. Choose patterns that fit your specific requirements and constraints.</p>","<p>API design affects how services communicate. Follow RESTful principles, use consistent naming, and provide comprehensive documentation.</p>","<p>Testing strategies ensure code quality and prevent regressions. Implement unit, integration, and end-to-end tests for comprehensive coverage.</p>"]},g={electron:"electron",architecture:"architecture",security:"security",packaging:"packaging",api:"api",performance:"performance",development:"development",maintenance:"maintenance",version:"maintenance",workflow:"development",optimization:"performance",native:"api",distribution:"packaging",best:"security",practices:"security"},h=(0,i(901).default)({name:"App",data:()=>({searchTerm:""}),computed:{filteredCards(){return u.map((e,t)=>{let i=this.fuzzySearch(e.title,this.searchTerm);return{...e,index:t,searchScore:i.score,highlightedTitle:i.highlightedText,matches:i.matches}}).filter(e=>e.matches).sort((e,t)=>t.searchScore-e.searchScore)}},methods:{fuzzySearch(e,t){if(!t||""===t.trim())return{matches:!0,highlightedText:e,score:1};let i=e.toLowerCase(),n=t.toLowerCase().trim();if(i===n)return{matches:!0,highlightedText:`<mark>${e}</mark>`,score:2};if(i.includes(n)){let t=i.indexOf(n),o=t+n.length,r=e.substring(0,t),a=e.substring(t,o),s=e.substring(o);return{matches:!0,highlightedText:`${r}<mark>${a}</mark>${s}`,score:1.5}}let o=n.split(""),r=0,a=0,s=[],l=0;for(;r<i.length&&a<o.length;)i[r]===o[a]&&(s.push(r),l+=1,a>0&&s[a-1]===r-1&&(l+=2),a++),r++;if(a===o.length){let t="",i=0;return s.forEach((n,o)=>{t+=e.substring(i,n),t+=`<mark>${e[n]}</mark>`,i=n+1}),t+=e.substring(i),l/=3*o.length,{matches:!0,highlightedText:t,score:l}}return{matches:!1,highlightedText:e,score:0}},processTitle(e,t){let i=this.fuzzySearch(e,t);return i.matches?i.highlightedText:e},handleCardClick(e,t){let{title:i,content:n}=e,o=[{name:"blue",bg:"#4a6cf7",color:"white"},{name:"green",bg:"#4ade80",color:"black"},{name:"purple",bg:"#a78bfa",color:"white"},{name:"red",bg:"#f87171",color:"white"},{name:"yellow",bg:"#fbbf24",color:"black"},{name:"indigo",bg:"#6366f1",color:"white"}];o[t%o.length];let r=function(e){let t=e.toLowerCase(),i="default";for(let[e,n]of Object.entries(g))if(t.includes(e)){i=n;break}let n=m[i]||m.default,o=[],r=Math.min(n.length,Math.max(2,Math.floor(3*Math.random())+2)),a=new Set;for(let e=0;e<r;e++){let e;do e=Math.floor(Math.random()*n.length);while(a.has(e)&&a.size<n.length);a.add(e),o.push(n[e])}let s=["<h4>Key Considerations</h4><ul><li>Best practices and patterns</li><li>Common pitfalls to avoid</li><li>Performance implications</li><li>Security aspects</li><li>Future trends and developments</li></ul>","<h4>Implementation Tips</h4><ul><li>Start with small, manageable components</li><li>Test early and often</li><li>Seek feedback regularly</li><li>Iterate based on results</li><li>Follow official documentation</li></ul>","<h4>Common Patterns</h4><ul><li>Established approaches</li><li>Community recommendations</li><li>Official guidelines</li><li>Proven solutions</li><li>Effective techniques</li></ul>","<h4>Advanced Topics</h4><ul><li>Complex implementations</li><li>Specialized use cases</li><li>Performance tuning</li><li>Security hardening</li><li>Production considerations</li></ul>"],l=[`
    <p><strong>About "${e}":</strong> This topic is essential in Electron application development.
    Understanding its concepts and implementation details will help you build better, more robust desktop applications.</p>
  `,...o,s[Math.floor(Math.random()*s.length)],`<p>For more information about "${e}", consult the official Electron documentation, community resources, and expert guides.
    Practical implementation and hands-on experience are crucial for mastering these concepts.</p>`].join("");return l&&""!==l.trim()?l:`<p><strong>About "${e}":</strong> This topic is important in Electron development.</p>
            <p>Understanding this concept will help you build better desktop applications.</p>
            <p>For more information, consult the official Electron documentation and resources.</p>`}(i),a=function(e){let t=e.toLowerCase(),i=[{name:"blue",bg:"#4a6cf7",color:"white"},{name:"green",bg:"#4ade80",color:"black"},{name:"purple",bg:"#a78bfa",color:"white"},{name:"red",bg:"#f87171",color:"white"},{name:"yellow",bg:"#fbbf24",color:"black"},{name:"indigo",bg:"#6366f1",color:"white"},{name:"pink",bg:"#ec4899",color:"white"},{name:"teal",bg:"#14b8a6",color:"white"},{name:"orange",bg:"#f97316",color:"white"},{name:"gray",bg:"#6b7280",color:"white"}],n=0;for(let e=0;e<t.length;e++)n=t.charCodeAt(e)+((n<<5)-n);let o=Math.abs(n)%i.length;return i[o]}(i),s=new d.A({title:i,html:`<div class="winbox-content"><h3 style="color: ${a.color};">${i}</h3><div style="color: ${a.color};" class="winbox-dynamic-content">Loading content...</div></div>`,width:"500px",height:"400px",x:"center",y:"center",class:"modern dark-theme",background:a.bg,border:4});setTimeout(()=>{if(s&&s.body){let e=s.body.querySelector(".winbox-dynamic-content");e?e.innerHTML=r:s.body.innerHTML=`<div class="winbox-content"><h3 style="color: ${a.color};">${i}</h3><div style="color: ${a.color};">${r}</div></div>`}},10)}}},[["render",function(e,t,i,d,u,m){return(0,n.uX)(),(0,n.CE)("div",o,[(0,n.Lk)("main",r,[(0,n.Lk)("div",a,[(0,n.bo)((0,n.Lk)("input",{type:"text",class:"search-input",placeholder:"Search topics...","onUpdate:modelValue":t[0]||(t[0]=e=>u.searchTerm=e),autocomplete:"off",spellcheck:"false"},null,512),[[n.Jo,u.searchTerm]]),(0,n.Lk)("div",s,[((0,n.uX)(!0),(0,n.CE)(n.FK,null,(0,n.pI)(m.filteredCards,(e,t)=>((0,n.uX)(),(0,n.CE)("div",{key:e.id||e.index,class:"simple-card",onClick:t=>m.handleCardClick(e,e.index),title:`Click to view details about ${e.title}`},[(0,n.Lk)("h3",{class:"simple-card-title",innerHTML:e.highlightedTitle},null,8,c)],8,l))),128)),0===m.filteredCards.length?((0,n.uX)(),(0,n.CE)("div",p," No matching topics found ")):(0,n.Q3)("",!0)])])]),t[1]||(t[1]=(0,n.Lk)("footer",{class:"App-footer"},[(0,n.Lk)("p",null,[(0,n.eW)("Electron + Vue Starter | "),(0,n.Lk)("code",null,"renderer-alt"),(0,n.eW)(" | Desktop Application")])],-1))])}],["__scopeId","data-v-0820ddaa"]]);(0,n.Ef)(h).mount("#root")}},r={};function a(e){var t=r[e];if(void 0!==t)return t.exports;var i=r[e]={exports:{}};return o[e](i,i.exports,a),i.exports}a.m=o,a.d=(e,t)=>{for(var i in t)a.o(t,i)&&!a.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},a.g=(()=>{if("object"==typeof globalThis)return globalThis;try{return this||Function("return this")()}catch(e){if("object"==typeof window)return window}})(),a.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),e=[],a.O=(t,i,n,o)=>{if(i){o=o||0;for(var r=e.length;r>0&&e[r-1][2]>o;r--)e[r]=e[r-1];e[r]=[i,n,o];return}for(var s=1/0,r=0;r<e.length;r++){for(var[i,n,o]=e[r],l=!0,c=0;c<i.length;c++)(!1&o||s>=o)&&Object.keys(a.O).every(e=>a.O[e](i[c]))?i.splice(c--,1):(l=!1,o<s&&(s=o));if(l){e.splice(r--,1);var p=n();void 0!==p&&(t=p)}}return t},t={410:0},a.O.j=e=>0===t[e],i=(e,i)=>{var n,o,[r,s,l]=i,c=0;if(r.some(e=>0!==t[e])){for(n in s)a.o(s,n)&&(a.m[n]=s[n]);if(l)var p=l(a)}for(e&&e(i);c<r.length;c++)o=r[c],a.o(t,o)&&t[o]&&t[o][0](),t[o]=0;return a.O(p)},(n=self.webpackChunkelectron_vue_rsbuild_bun=self.webpackChunkelectron_vue_rsbuild_bun||[]).forEach(i.bind(null,0)),n.push=i.bind(null,n.push.bind(n));var s=a.O(void 0,["328","322"],()=>a(976));s=a.O(s)})();